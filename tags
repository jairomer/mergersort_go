!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_OUTPUT_EXCMD	mixed	/number, pattern, mixed, or combineV2/
!_TAG_OUTPUT_FILESEP	slash	/slash or backslash/
!_TAG_OUTPUT_MODE	u-ctags	/u-ctags or e-ctags/
!_TAG_PATTERN_LENGTH_LIMIT	96	/0 for no limit/
!_TAG_PROC_CWD	/home/neusynk/Workspace/repos/mergesort_go/	//
!_TAG_PROGRAM_AUTHOR	Universal Ctags Team	//
!_TAG_PROGRAM_NAME	Universal Ctags	/Derived from Exuberant Ctags/
!_TAG_PROGRAM_URL	https://ctags.io/	/official site/
!_TAG_PROGRAM_VERSION	5.9.0	/p5.9.20210110.0/
BenchmarkGoSortA	mergesort_test.go	/^func BenchmarkGoSortA(b *testing.B) {$/;"	f	package:mergesort
BenchmarkGoSortB	mergesort_test.go	/^func BenchmarkGoSortB(b *testing.B) {$/;"	f	package:mergesort
BenchmarkSort	mergesort_test.go	/^func BenchmarkSort(b *testing.B) {$/;"	f	package:mergesort
GoSortA	mergesort.go	/^func GoSortA(in []int) []int {$/;"	f	package:mergesort	typeref:typename:[]int
GoSortB	mergesort.go	/^func GoSortB(in []int) []int {$/;"	f	package:mergesort	typeref:typename:[]int
How?	README.md	/^## How?$/;"	s	chapter:mergersort_go
S	parallel_mergesort.go	/^var S [][]int$/;"	v	package:mergesort	typeref:typename:[][]int
Sort	mergesort.go	/^func Sort(in []int) []int {$/;"	f	package:mergesort	typeref:typename:[]int
SortParallel	parallel_mergesort.go	/^func SortParallel(in []int) []int {$/;"	f	package:mergesort	typeref:typename:[]int
TestGoSortA1	mergesort_test.go	/^func TestGoSortA1(t *testing.T) {$/;"	f	package:mergesort
TestGoSortA2	mergesort_test.go	/^func TestGoSortA2(t *testing.T) {$/;"	f	package:mergesort
TestGoSortA3	mergesort_test.go	/^func TestGoSortA3(t *testing.T) {$/;"	f	package:mergesort
TestGoSortA4	mergesort_test.go	/^func TestGoSortA4(t *testing.T) {$/;"	f	package:mergesort
TestGoSortB1	mergesort_test.go	/^func TestGoSortB1(t *testing.T) {$/;"	f	package:mergesort
TestGoSortB2	mergesort_test.go	/^func TestGoSortB2(t *testing.T) {$/;"	f	package:mergesort
TestGoSortB3	mergesort_test.go	/^func TestGoSortB3(t *testing.T) {$/;"	f	package:mergesort
TestGoSortB4	mergesort_test.go	/^func TestGoSortB4(t *testing.T) {$/;"	f	package:mergesort
TestSort1	mergesort_test.go	/^func TestSort1(t *testing.T) {$/;"	f	package:mergesort
TestSort2	mergesort_test.go	/^func TestSort2(t *testing.T) {$/;"	f	package:mergesort
TestSort3	mergesort_test.go	/^func TestSort3(t *testing.T) {$/;"	f	package:mergesort
TestSort4	mergesort_test.go	/^func TestSort4(t *testing.T) {$/;"	f	package:mergesort
TesttoStr	mergesort_test.go	/^func TesttoStr(t *testing.T) {$/;"	f	package:mergesort
What is this?	README.md	/^## What is this?$/;"	s	chapter:mergersort_go
Why?	README.md	/^## Why?$/;"	s	chapter:mergersort_go
channels	parallel_mergesort.go	/^var channels []chan []int$/;"	v	package:mergesort	typeref:typename:[]chan []int
concurrentMerge	mergesort.go	/^func concurrentMerge(arr []int, left int, middle int, right int) []int{$/;"	f	package:mergesort	typeref:typename:[]int
merge	mergesort.go	/^func merge(arr []int, left int, middle int, right int) {$/;"	f	package:mergesort
mergeSort	mergesort.go	/^func mergeSort(arr []int, l int, r int) {$/;"	f	package:mergesort
mergersort_go	README.md	/^# mergersort_go$/;"	c
mergesort	mergesort.go	/^package mergesort$/;"	p
mergesort	mergesort_test.go	/^package mergesort$/;"	p
mergesort	parallel_mergesort.go	/^package mergesort$/;"	p
mergesort	parallel_mergesort_test.go	/^package mergesort$/;"	p
parallelMultiwayMergesort	parallel_mergesort.go	/^func parallelMultiwayMergesort(in []int, processor_count int) []int{$/;"	f	package:mergesort	typeref:typename:[]int
pipelinedConcurrentMergeSort	mergesort.go	/^func pipelinedConcurrentMergeSort(arrr []int, l int, r int) []int {$/;"	f	package:mergesort	typeref:typename:[]int
toStr	mergesort_test.go	/^func toStr(in []int) string {$/;"	f	package:mergesort	typeref:typename:string
trivialConcurrentMergeSort	mergesort.go	/^func trivialConcurrentMergeSort(arr []int, l int, r int) {$/;"	f	package:mergesort
